# auto-generated by grc.converter

id: mesa_SignalDetector
label: Signal Detector
category: '[mesa]'

parameters:
-   id: fft_size
    label: FFT Size
    dtype: int
    default: '1024'
-   id: squelchThreshold
    label: Sig Detect Threshold
    dtype: float
    default: '-80.0'
-   id: minWidthHz
    label: Min Signal Width (Hz)
    dtype: float
    default: '6000.0'
-   id: maxWidthHz
    label: Max Signal Width (Hz)
    dtype: float
    default: '60000.0'
-   id: radioCenterFreq
    label: Radio Frequency
    dtype: float
    default: freq
-   id: sampleRate
    label: Sample Rate
    dtype: float
    default: samp_rate
-   id: holdUpSec
    label: Hold Time (s)
    dtype: float
    default: '10.0'
-   id: framesToAvg
    label: Frames to Avg
    dtype: int
    default: '6'
-   id: detectionMethod
    label: Detection Method
    dtype: enum
    options: ['1', '2']
    option_labels: [Separate Signals, Single Channelized (Boxing)]
-   id: genSignalPDUs
    label: Gen Signal PDUs
    dtype: enum
    options: ['False', 'True']
    option_labels: ['Off', 'On']
-   id: enableDebug
    label: Debug
    dtype: enum
    options: ['False', 'True']
    option_labels: ['Off', 'On']

inputs:
-   domain: stream
    dtype: complex
-   domain: message
    id: msgin
    optional: true

outputs:
-   label: signal
    domain: stream
    dtype: complex
-   domain: message
    id: signaldetect
    optional: true
-   domain: message
    id: state
    optional: true
-   domain: message
    id: signals
    optional: true

templates:
    imports: import mesa
    make: "mesa.SignalDetector(${fft_size}, ${squelchThreshold}, ${minWidthHz}, ${maxWidthHz},\
        \ ${radioCenterFreq}, ${sampleRate}, \n  \t\t\t${holdUpSec}, ${framesToAvg},\
        \ ${genSignalPDUs}, ${enableDebug},${detectionMethod})"
    callbacks:
    - setSquelch(${squelchThreshold})
    - setMinWidthHz(${minWidthHz})
    - setMaxWidthHz(${maxWidthHz})
    - setCenterFrequency(${radioCenterFreq})

documentation: "This block scans the input signal looking for sub signals of the specified\
    \ min/max width.  The block takes a max-hold average to inspect the spectrum,\
    \ then determines any signals present.  Note that the FFT frames to average is\
    \ configurable.  Too small and the detection is jittery, too high and too many\
    \ samples will be held/processed so pick a number that works well (or stick with\
    \ the default).\n\nWhen a signal is detected, a PDU will be generated on the signaldetect\
    \ connector with a 'state' metadata tag set to 1.  PDU's are only sent on state\
    \ changes, so any downstream blocks should track their own state.  When no signals\
    \ are present and the hold timer has expired, a PDU will be generated with 'state'\
    \ set to 0.\n\nIf more data processing is desired, 'Gen Signal PDUs' can be turned\
    \ on.  In that case, for each detected signal, a PDU is generated along with some\
    \ metadata (radio freq, sample rate, signal center freq, signal width, and signal\
    \ max power) along with the full data block.  This can be used downstream to tune\
    \ filters and/or shift the signal.  \n\nNOTES: \n\nUsing the standard 'out' source\
    \ only produces a single pipeline, however: THE OUTPUT 'SIGNALS' MESSAGE SOURCE\
    \ CONNECTOR SENDS A MESSAGE FOR EACH DETECTED SIGNAL IN A GIVEN INPUT BUFFER.\
    \  This means that the out data will be sent along with the detected signal info\
    \ for EACH detected signal in a given input buffer.  If you write this to say\
    \ a file sink or assume it's a single pipeline downstream, it's NOT!\n\nFor the signal detect threshold,\
    \ pick a number that's above any noise floor to avoid false positives.  The detector looks for the upward\
    \ transition from this squelch threshold, therefore everything that's not a signal\
    \ should be below this threshold, such that everything above it can be assumed\
    \ to be a signal."

file_format: 1
